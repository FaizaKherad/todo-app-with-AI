# Feature Specification: Local Cloud-Native Deployment (Minikube)

**Feature Branch**: `004-cloud-native-minikube`
**Created**: 2025-12-24
**Status**: Draft
**Input**: User description: "Phase IV Specification: Local Cloud-Native Deployment (Minikube) ## Phase Overview Phase IV transitions the Todo application and conversational AI system into a **cloud-native architecture**, deployed **locally using Minikube**. This phase introduces: - Containerization - Kubernetes orchestration - MCP-based AI tool invocation within the cluster All functionality from Phases I–III MUST remain unchanged in behavior. --- ## Dependencies - Phase I: Core Todo Engine - Phase II: Persistence & Validation - Phase III: Conversational AI Interface (Chatkit + Agents SDK + MCP) Phase IV MUST NOT modify business logic or AI intent behavior. --- ## Scope ### In Scope - Docker containerization of the application - Kubernetes manifests generation - Minikube deployment - MCP server running inside the cluster - Local service exposure for chat interaction ### Out of Scope - Cloud providers (handled in Phase V) - Autoscaling - Ingress controllers beyond basic service exposure - Authentication or authorization - UI beyond terminal or HTTP-based chat interface --- ## Cloud-Native Architecture ### Components The system MUST consist of the following Kubernetes workloads: 1. **todo-app** - Hosts: - Core Todo Engine (Phases I–II) - Conversational AI Agent (Phase III) - Exposes MCP tools internally 2. **mcp-server** - Implements Official MCP SDK - Registers Todo operations as MCP tools - Accessible only within the cluster --- ## Containerization Rules ### Docker Image Requirements - A single Docker image MUST be built for the todo application - The image MUST: - Contain application runtime - Expose a configurable service port - Be runnable without modification in Minikube ### Prohibited Actions - No manual Dockerfile editing - Dockerfile MUST be generated by Qwen from this spec --- ## Kubernetes Deployment Requirements ### Namespace - All resources MUST be deployed into a namespace named: todo-phase-iv yaml Copy code --- ### Deployments #### todo-app Deployment - Replicas: 1 - Restart policy: Always - Environment variables MUST include: - MCP_SERVER_URL - STORAGE_PATH (mounted volume path) --- ### Services - A Kubernetes Service MUST expose `todo-app` - Service type: - NodePort OR ClusterIP with Minikube tunnel - Service MUST allow local user access to chat interface --- ## Persistent Storage in Kubernetes ### Volume Requirements - Use a PersistentVolumeClaim (PVC) - Storage MUST persist: - `tasks.json` - PVC MUST be mounted into the todo-app container ### Persistence Guarantees - Task data MUST survive pod restarts - Data persistence MUST behave identically to Phase II --- ## MCP Integration (Cluster-Aware) ### MCP Tool Exposure - MCP server MUST expose the following tools: - add_task - view_tasks - update_task - delete_task - complete_task ### Invocation Rules - The AI agent MUST communicate with MCP server via internal service DNS - No direct filesystem or memory access to task state is allowed from the agent --- ## Networking Rules - MCP server MUST NOT be publicly exposed - todo-app MUST be accessible locally from the developer machine - All inter-service communication MUST use Kubernetes DNS --- ## Minikube-Specific Constraints - The system MUST be deployable using: kubectl apply -f <generated-manifests> yaml Copy code - No Helm charts - No external operators - No cloud-specific annotations --- ## Observability & Logs - Application logs MUST be written to stdout - Kubernetes MUST capture logs via `kubectl logs` - No external monitoring systems are required --- ## Failure Handling - If MCP server is unavailable: - AI MUST return a service-unavailable error - If storage volume fails: - Todo operations MUST fail safely - No data corruption is permitted --- ## Non-Goals (Explicit Exclusions) The system MUST NOT: - Auto-scale pods - Deploy to cloud providers - Use managed databases - Introduce message queues - Use ingress controllers - Introduce service meshes --- ## Acceptance Criteria Phase IV is complete when: - The entire system runs inside Minikube - Tasks persist across pod restarts - Conversational AI works via local access - MCP tools are invoked correctly inside the cluster - Kubernetes manifests are fully AI-generated - No manual edits exist in Docker or YAML files - All behavior matches Phases I–III exactly"

## User Scenarios & Testing *(mandatory)*

### User Story 1 - Deploy Application to Minikube (Priority: P1)

As a developer, I want to deploy the Todo application to a local Minikube cluster so that I can run it in a cloud-native environment.

**Why this priority**: This is the foundational requirement for Phase IV - without successful deployment to Minikube, none of the other functionality can be tested.

**Independent Test**: The system can be tested by deploying the application to Minikube and verifying all components are running, delivering the core value of cloud-native deployment.

**Acceptance Scenarios**:

1. **Given** I have Minikube installed and running, **When** I run `kubectl apply -f manifests/`, **Then** all components (todo-app and mcp-server) are deployed and running in the cluster.
2. **Given** I have applied the Kubernetes manifests, **When** I check the deployment status, **Then** all pods are in "Running" state.
3. **Given** the application is deployed, **When** I access the todo-app service, **Then** I can interact with the application normally.

---

### User Story 2 - Access Chat Interface Locally (Priority: P1)

As a user, I want to access the conversational AI interface locally after deployment to Minikube so that I can continue to use the application as before.

**Why this priority**: This ensures the core functionality from previous phases remains accessible after the cloud-native transformation.

**Independent Test**: The system can be tested by accessing the deployed service and using the conversational interface, delivering the value of continued usability.

**Acceptance Scenarios**:

1. **Given** the application is deployed to Minikube, **When** I access the service locally, **Then** I can interact with the AI assistant.
2. **Given** I have access to the chat interface, **When** I enter natural language commands, **Then** they are processed correctly as in previous phases.
3. **Given** the service is running, **When** I check the application logs, **Then** I can see the interactions via `kubectl logs`.

---

### User Story 3 - Persist Tasks Across Pod Restarts (Priority: P1)

As a user, I want my tasks to persist across pod restarts so that data is not lost when the application is updated or crashes.

**Why this priority**: This ensures that the persistence functionality from Phase II continues to work in the cloud-native environment.

**Independent Test**: The system can be tested by creating tasks, restarting the pod, and verifying tasks remain, delivering the value of data persistence.

**Acceptance Scenarios**:

1. **Given** I have created tasks in the deployed application, **When** I delete the pod causing it to restart, **Then** my tasks are preserved.
2. **Given** the application has persisted tasks, **When** I scale down and back up the deployment, **Then** the tasks remain intact.
3. **Given** I have tasks in the system, **When** I update the deployment configuration and roll out changes, **Then** the tasks persist.

---

### User Story 4 - MCP Tools Operate Internally (Priority: P2)

As a system, I want MCP tools to operate internally within the cluster so that AI and core functionality are properly decoupled.

**Why this priority**: This implements the required architecture where the AI communicates with MCP tools via internal service DNS rather than direct access.

**Independent Test**: The system can be tested by verifying internal communication between components, delivering the value of proper service architecture.

**Acceptance Scenarios**:

1. **Given** both todo-app and mcp-server are deployed, **When** the AI component makes a request, **Then** it communicates with the mcp-server via internal service DNS.
2. **Given** the MCP server is running, **When** the todo-app requests task operations, **Then** they are routed through the MCP tools.
3. **Given** the system is functioning, **When** the MCP server is temporarily unavailable, **Then** the AI returns appropriate service-unavailable errors.

---

### Edge Cases

- What happens when Minikube is not running? (Should provide clear error message about requirements)
- How does the system handle insufficient disk space for the PVC? (Should fail gracefully with appropriate error)
- What happens when the cluster runs out of resources? (Should fail gracefully)
- How does the system handle network partitions between services? (Should return appropriate errors)

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: System MUST deploy to Minikube using kubectl apply -f <manifests>
- **FR-002**: System MUST run in a namespace named "todo-phase-iv"
- **FR-003**: System MUST include a todo-app deployment with 1 replica
- **FR-004**: System MUST include an mcp-server deployment with 1 replica
- **FR-005**: todo-app deployment MUST have restart policy set to Always
- **FR-006**: todo-app deployment MUST include environment variables MCP_SERVER_URL and STORAGE_PATH
- **FR-007**: System MUST expose todo-app via a Kubernetes Service
- **FR-008**: Service MUST be accessible locally (NodePort or ClusterIP with tunnel)
- **FR-009**: System MUST use a PersistentVolumeClaim for task persistence
- **FR-010**: PVC MUST mount to the todo-app container and persist tasks.json
- **FR-011**: Task data MUST survive pod restarts
- **FR-012**: AI component MUST communicate with MCP server via internal service DNS
- **FR-013**: MCP server MUST expose add_task, view_tasks, update_task, delete_task, and complete_task tools
- **FR-014**: AI component MUST NOT have direct access to task state (filesystem or memory)
- **FR-015**: MCP server MUST NOT be publicly exposed outside the cluster
- **FR-016**: Application logs MUST be written to stdout for Kubernetes collection
- **FR-017**: System MUST return service-unavailable errors when MCP server is unreachable
- **FR-018**: System MUST fail task operations safely when storage volume fails
- **FR-019**: All Phase I-III functionality MUST remain unchanged in behavior
- **FR-020**: Docker image MUST contain application runtime and expose configurable service port

### Key Entities *(include if feature involves data)*

- **todo-app**: Kubernetes deployment hosting the core Todo Engine and Conversational AI
- **mcp-server**: Kubernetes deployment implementing MCP tools for task operations
- **tasks.json**: Persistent file containing task data, stored on PVC
- **PersistentVolumeClaim**: Kubernetes resource for persistent task storage
- **Kubernetes Service**: Network abstraction to expose the todo-app to local access

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: Application successfully deploys to Minikube with kubectl apply (100% success rate)
- **SC-002**: All components (todo-app and mcp-server) run in "Running" state after deployment
- **SC-003**: Users can access the conversational interface locally after deployment (100% accessibility)
- **SC-004**: Tasks persist across pod restarts (100% of tasks remain after restart)
- **SC-005**: Tasks persist across deployment updates (100% of tasks remain after updates)
- **SC-006**: AI communicates with MCP server via internal service DNS (100% of requests use proper routing)
- **SC-007**: All Phase I-III functionality works identically in cloud-native deployment
- **SC-008**: Application logs are accessible via kubectl logs (100% log visibility)
- **SC-009**: System handles MCP server unavailability gracefully (100% of failures result in proper errors)
- **SC-010**: System handles storage failures safely without data corruption (100% safe failure handling)